# -*- coding: utf-8 -*-
"""Analyzing Model Compression Techniques for Language Models

Automatically generated by Colaboratory.

# Harsha Vardhan (hv2237)
# Alex Brebenel (ab5181)

# Quantization for Regular Model Training

# Steps for training and comparing RoBERTa-Large and the I-BERT 

### 1. Set up
### 2. Create a dataset
### 3. Build the model
### 4. Test model performance and measure runtime
"""

# Make sure to have these packages installed
# %%capture
# !pip install transformers numpy pandas nlp matplotlib torch
# !pip install nltk pytorch_lightning math os torchmatrics
# !pip install pytorch-lightning nlp
#

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from google.colab import drive
from nlp import load_dataset
from nlp import list_datasets
import pandas as pd
from torch.utils.data import Dataset
import torch
from transformers import AutoTokenizer, IBertModel
from nltk.tokenize import word_tokenize
import pytorch_lightning as pl
from torch.utils.data import DataLoader
from transformers import AutoModel, AdamW, get_cosine_schedule_with_warmup
import torch.nn as nn
import math
from torchmetrics.functional.classification import auroc
import torch.nn.functional as F


# The Dataset object used for training
class Quantize_Dataset(Dataset):

  def __init__(self, data_path, tokenizer, attributes, max_token_len: int = 128, sample = 5000):
    self.data_path = data_path
    self.tokenizer = tokenizer
    self.attributes = attributes
    self.max_token_len = max_token_len
    self.sample = sample
    self._prepare_data()


  def _prepare_data(self):
    data = pd.read_csv(self.data_path,sep = '\t', header=None, names=["source", "label", "label_original", "sentence"])
    self.data = data
    
  def __len__(self):
    return len(self.data)

  def __getitem__(self, index):
    item = self.data.iloc[index]
    #print(item)
    sentence = str(item.sentence)
    attributes = torch.FloatTensor(item[self.attributes])
    tokens = self.tokenizer.encode_plus(sentence,
                                        add_special_tokens=True,
                                        return_tensors='pt',
                                        truncation=True,
                                        padding='max_length',
                                        max_length=self.max_token_len,
                                        return_attention_mask = True)
    return {'input_ids': tokens.input_ids.flatten(), 'attention_mask': tokens.attention_mask.flatten(), 'labels': attributes}


# Data Module Class
class Quantize_Data_Module(pl.LightningDataModule):

  # When we are doing regular model, the regular RoBERTa-Large model is selected
  # When we are doing quantized model, the i-BERT model is selected

  #def __init__(self, train_path, val_path, attributes, batch_size: int = 16, max_token_length: int = 128, model_name = 'roberta-large'):
  def __init__(self, train_path, val_path, attributes, batch_size: int = 16, max_token_length: int = 128, model_name='kssteven/ibert-roberta-large'):
    super().__init__()
    self.train_path = train_path
    self.val_path = val_path
    self.attributes = attributes
    self.batch_size = batch_size
    self.max_token_length = max_token_length
    self.model_name = model_name
    
    # When we are doing regular model, the regular RoBERTa-Large model is selected
    # When we are doing quantized model, the i-BERT model is selected
    self.tokenizer = tokenizer = AutoTokenizer.from_pretrained("kssteven/ibert-roberta-base")
    #self.tokenizer = AutoTokenizer.from_pretrained(model_name)

  def setup(self, stage = None):
    if stage in (None, "fit"):
      self.train_dataset = Quantize_Dataset(self.train_path, attributes=self.attributes, tokenizer=self.tokenizer)
      self.val_dataset = Quantize_Dataset(self.val_path, attributes=self.attributes, tokenizer=self.tokenizer, sample=None)
    if stage == 'predict':
      self.val_dataset = Quantize_Dataset(self.val_path, attributes=self.attributes, tokenizer=self.tokenizer, sample=None)

  def train_dataloader(self):
    return DataLoader(self.train_dataset, batch_size = self.batch_size, num_workers=4, shuffle=True)

  def val_dataloader(self):
    return DataLoader(self.val_dataset, batch_size = self.batch_size, num_workers=4, shuffle=False)

  def predict_dataloader(self):
    return DataLoader(self.val_dataset, batch_size = self.batch_size, num_workers=4, shuffle=False)


# Classifier class for PyTorch Lightning
class Quantize_Comment_Classifier(pl.LightningModule):

  def __init__(self, config: dict):
    super().__init__()
    self.config = config
    self.pretrained_model = AutoModel.from_pretrained(config['model_name'], return_dict = True)
    self.hidden = torch.nn.Linear(self.pretrained_model.config.hidden_size, self.pretrained_model.config.hidden_size)
    self.classifier = torch.nn.Linear(self.pretrained_model.config.hidden_size, self.config['n_labels'])
    torch.nn.init.xavier_uniform_(self.classifier.weight)
    self.loss_func = nn.BCEWithLogitsLoss(reduction='mean')
    self.dropout = nn.Dropout()
    
  def forward(self, input_ids, attention_mask, labels=None):
    # roberta layer
    output = self.pretrained_model(input_ids=input_ids, attention_mask=attention_mask)
    pooled_output = torch.mean(output.last_hidden_state, 1)
    # final logits
    pooled_output = self.dropout(pooled_output)
    pooled_output = self.hidden(pooled_output)
    pooled_output = F.relu(pooled_output)
    pooled_output = self.dropout(pooled_output)
    logits = self.classifier(pooled_output)
    # calculate loss
    loss = 0
    if labels is not None:
      loss = self.loss_func(logits.view(-1, self.config['n_labels']), labels.view(-1, self.config['n_labels']))
    return loss, logits

  def training_step(self, batch, batch_index):
    loss, outputs = self(**batch)
    self.log("train loss ", loss, prog_bar = True, logger=True)
    return {"loss":loss, "predictions":outputs, "labels": batch["labels"]}

  def validation_step(self, batch, batch_index):
    loss, outputs = self(**batch)
    self.log("validation loss ", loss, prog_bar = True, logger=True)
    return {"val_loss": loss, "predictions":outputs, "labels": batch["labels"]}

  def predict_step(self, batch, batch_index):
    loss, outputs = self(**batch)
    return outputs

  def configure_optimizers(self):
    optimizer = AdamW(self.parameters(), lr=self.config['lr'], weight_decay=self.config['weight_decay'])
    total_steps = self.config['train_size']/self.config['batch_size']
    warmup_steps = math.floor(total_steps * self.config['warmup'])
    warmup_steps = math.floor(total_steps * self.config['warmup'])
    scheduler = get_cosine_schedule_with_warmup(optimizer, warmup_steps, total_steps)
    return [optimizer],[scheduler]




def main():
    
    # Check specs
    #!nvidia-smi
    
    # See lists of datasets you could pick from
    datasets_list = list_datasets()
    len(datasets_list)

    print(', '.join(dataset.id for dataset in datasets_list))


    #dataset = load_dataset('glue')

    #Please pick one among the available configs: ['cola', 'sst2', 'mrpc', 'qqp', 'stsb', 'mnli', 'mnli_mismatched', 'mnli_matched', 'qnli', 'rte', 'wnli', 'ax']

            #`load_dataset('glue', 'cola')`
    #dataset = load_dataset('glue')
    #dataset = load_dataset('glue', 'cola')
    #print(dataset)

    # Due to complications, you need to access raw/tokenized data by downloading it and adding it to proper directories
    # CoLa files are in the ./raw directory. Need to download/have them for this code to work
    # CoLa filepaths are established here. These need to change if you put these files somewhere else
    train_path = './raw/in_domain_train.tsv'
    val_path = './raw/in_domain_dev.tsv'

    train_data = pd.read_csv(train_path,sep = '\t', header=None, names=["source", "label", "label_original", "sentence"])
    display(train_data)

    train_data.head(20)
    
    #################
    
    # When we are doing regular model, the regular RoBERTa-Large model is selected
    # When we are doing quantized model, the i-BERT model is selected
    model_name = 'kssteven/ibert-roberta-large'
    #model_name = 'roberta-large'
    tokenizer = AutoTokenizer.from_pretrained("kssteven/ibert-roberta-base")
    #tokenizer = AutoTokenizer.from_pretrained(model_name)
    attributes = ["label"] #["source", "label", "label_original", "sentence"]
    print(attributes)
    
    # Instantiate the Dataset
    quant_ds = Quantize_Dataset(train_path, tokenizer, attributes=attributes)
    quant_ds_val = Quantize_Dataset(val_path, tokenizer, attributes=attributes, sample=None)

    quant_ds.__getitem__(0)['labels'].shape, quant_ds.__getitem__(0)['input_ids'].shape, quant_ds.__getitem__(0)['attention_mask'].shape

    quant_ds.__getitem__(0)

    len(quant_ds)

    len(quant_ds_val)

    
    #################################################
    
    # Instantiate the Data module
    Quantize_data_module = Quantize_Data_Module(train_path, val_path, attributes=attributes)

    Quantize_data_module.setup()

    Quantize_data_module.train_dataloader()

    len(Quantize_data_module.train_dataloader())
    
    ##################################################
    
    # Set up model configurations, can change values to experiment
    config = {
    'model_name': 'distilroberta-base',
    'n_labels': len(attributes),
    'batch_size': 128,
    'lr': 1.5e-6,
    'warmup': 0.2, 
    'train_size': len(Quantize_data_module.train_dataloader()),
    'weight_decay': 0.001,
    'n_epochs': 30
    }

    model = Quantize_Comment_Classifier(config)

    idx=0
    input_ids = quant_ds.__getitem__(idx)['input_ids']
    attention_mask = quant_ds.__getitem__(idx)['attention_mask']
    labels = quant_ds.__getitem__(idx)['labels']
    model.cpu()
    loss, output = model(input_ids.unsqueeze(dim=0), attention_mask.unsqueeze(dim=0), labels.unsqueeze(dim=0))
    print(labels.shape, output.shape, output)

   
 
    Quantize_data_module = Quantize_Data_Module(train_path, val_path, attributes=attributes, batch_size=config['batch_size'])
    Quantize_data_module.setup()

    # model
    model = Quantize_Comment_Classifier(config)

    # Instantiate and Start Timer to see how long training occurs for
    start = torch.cuda.Event(enable_timing=True)
    end = torch.cuda.Event(enable_timing=True)

    start.record()

    # trainer and fit, run trainer
    trainer = pl.Trainer(max_epochs=config['n_epochs'], num_sanity_val_steps=50)
    trainer.fit(model, Quantize_data_module)

    end.record()


    # Waits for everything to finish running
    torch.cuda.synchronize()
    
    print()
    print()
    print("Time Spent Running:")
    print(start.elapsed_time(end))

    ##################################################################

    # Commented out, But if possible, you can uncomment and run Tensor Board to visualize stats
    #%reload_ext tensorboard
    #%load_ext tensorboard
    #%tensorboard --logdir ./lightning_logs/

    ##################################################################
